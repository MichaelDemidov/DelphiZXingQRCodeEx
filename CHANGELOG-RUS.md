Список изменений 
================

По сравнению с оригинальным проектом DelphiZXingQRCode от Debenu были изменены следующие вещи:

## 1. Поддержка нестандартных кодировок, определяемых программистом ##

Хотя стандарт QR фиксирует все возможные кодировки, иногда бывает нужно добавить какую-то специальную «псевдо-кодировку».
Например, Сбербанк России рекомендует использовать Win-1251 или KOI-8 (которые в стандарте QR не предусмотрены). Бывают
и другие ситуации. Скажем, удобно было бы реализовать возможность кодировать URL-адреса, содержащие нелатинские символы
(которые заменяются UTF-8 кодами со знаком %). Для поддержки таких нетрадиционных способов кодирования были внесены
следующие изменения:

1. Класс *TEncoder* и связанные с ним типы данных перемещены из секции *implementation* в секцию *interface* файла
*DelphiZXIngQRCode.pas*.
2. Три метода класса *TEncoder* (*ChooseMode*, *FilterContent*, *AppendBytes*) перемещены в секцию *protected*
и стали виртуальными. Так что теперь заинтересованный программист может добавлять собственные классы-кодировщики,
просто производя потомков от класса *TEncoder* (ради чего всё и затевалось). Все остальные пункты из этого списка —
лишь следствия этого решения.
3. Вместо перечислимого типа *TQRCodeEncoding* сделан набор целочисленных констант *ENCODING_…,* а класс
*TDelphiZXingQRCode* получил новый метод *RegisterEncoder*. Теперь программист, создав собственный класс-кодировщик,
может определить его как стандартный для новой кодировки (или даже для старой, если его что-то не устраивает). Для
получения информации об определённых кодировщиках предусмотрен новый метод *GetEncoderClass*.
4. У компонента *TDelphiZXingQRCode* появилось свойство *FilteredData*, которое позволяет узнать, что именно
записывается в QR-код (это полезно скорее для самоконтроля, поскольку входная строка преобразуется кодировщиком,
и входные данные могут отличаться от записанных). У класса *TEncoder* доработан метод *Encode:* теперь он возвращает
именно эту строку.
5. Удалена глобальная функция *GenerateQRCode*. Весь код теперь выполняется непосредственно внутри класса
*TDelphiZXingQRCode* (метод *Update*, который по такому случаю перемещён в секцию *public* класса). Это, во-первых,
проще, во-вторых, без этого манипулировать разными кодировщиками было бы неудобно.
6. Добавлены примеры кодировщиков, определённых программистом. Это *TWin1251Encoder* (кодировка Win-1251) в модуле
*QR\_Win1251.pas* и *TURLEncoder* (кодирование URL с нелатинскими символами) в модуле *QR\_URL.pas*.

## 2. Уровень коррекции ошибок ##

Вообще-то, он был в оригинальной библиотеке ZXing, но при портировании на Delphi его «сломали». Странно, что авторы
за год так и не исправили эту ошибку сами, хотя она им определённо известна.

1. Добавлено свойство *TDelphiZXingQRCode.ErrorCorrectionOrdinal*. Это свойство перечислимого типа, соответствующего
одному из четырёх уровней коррекции ошибок (L, M, H, Q).
2. Класс *TErrorCorrectionLevel* переписан (хотя что там было переписывать…).

## 3. Исключения ##

DelphiZXingQRCode вообще почти не содержит каких-то обработок исключений. Например, если закодированная строка
не влезает в отведённый размер, определённый стандартом QR-кодирования, то программа попросту выдаёт Access Violation.
Мне это показалось неправильным, и я добавил класс-исключение *EQRMatrixTooLarge*.

## 4. Другие новые свойства, методы и события класса *TDelphiZXingQRCode* ##

1. У класса *TDelphiZXingQRCode* добавлены события *BeforeUpdate* и *AfterUpdate*, которые вызываются до и после
генерации кода, соответственно. Первый позволяет, например, проверить входную строку, а второй — обеспечить перерисовку
картинки с кодом после изменения.
2. Добавлены методы *BeginUpdate* и *EndUpdate*, которые позволяют временно заблокировать формирование матрицы при
одновременном изменении большого количества свойств.

## 5. Новая глобальная настройка для кодировки по умолчанию ##

Глобальная переменная *DefaultNonISOEncoding* — это кодировка по умолчанию для всех объектов типа *TDelphiZXIngQRCode*.
Она применяется в том случае, когда свойство *Encoding* = ENCODING_AUTO, а кодируемая строка содержит символы, не
являющиеся символами ISO (то есть латинскими буквами, цифрами и т.д.).

По умолчанию используется ENCODING_UTF8_NOBOM, но программист может задать другое значение или вовсе придумать
собственный способ кодирования (переопределив класс *TEncoder,* разумеется).

## 6. Добавлена поддержка Lazarus ##

Внесены некоторые исправления для обеспечения совместимости с Lazarus (проверялось на версии 1.2.6 для Windows).
Основные модули (*DelphiZXIngQRCode.pas*, *QR_URL.pas* и *QR_Win1251.pas*) компилируются без изменений, а вот в модуле
*QRGraphics.pas* имеется одна мелкая неприятность: в стандартных модулях Lazarus (в частности, *Graphics.pas*)
отсутствует поддержка класса *TMetafile*. Это можно исправить, например, подключив к проекту (и добавив в секцию *uses*
модуля *QRGraphics.pas*) модуль *TADrawerWMF.pas*, поставляемый в составе библиотеки TAChart, которая устанавливается
вместе с Lazarus. Путь к файлу выглядит как-то так (под Windows): *…\lazarus\components\tachart\tadrawerwmf.pas.*
В этом случае для компиляции модуля *QRGraphics.pas* достаточно убрать (закомментировать) в процедуре *MakeMetafile*
строку *Enhanced := True;* (эта реализация класса *TMetafile* её не поддерживает).

Исправленный для совместимости с Lazarus исходник демонстрационного проекта также прилагается
(файл *TestApp\Lazarus-src.zip*).

## 7. Исправление ошибок, рефакторинг и другие улучшения кода ##

* Много рефакторинга для улучшения читаемости кода. Удалены ненужные скобки после *if* (наследие Java), бесполезные
пары *begin / end* вокруг одной строки и т.п.

-------------------------

**Пример**

было:

<pre><code>if (I = 1) then
begin
    Exit;    
end;
</code></pre>

стало:

<pre><code>if I = 1 then
    Exit;
</code></pre>

-------------------------

Самый объёмный пример: в одной подпрограмме заменил 40 подряд идущих *if … then … else if … then … else* на один оператор
*case,* которому там самое место.

Итог: в общей сложности объём кода сократился более чем на 200 строк, несмотря на добавленные свойства, методы и прочее
перечисленное выше.

* В нескольких местах пришлось разбираться с пустыми блоками *if / then* и *try / except* (фрагменты кода, которые должны
были быть внутри, оказались снаружи этих блоков).
 
* Удалено пустое объявление класса *TCharacterSetECI*.

* Внутренняя структура классов (*private / public / protected* поля, свойства и методы) была несколько хаотична. «Причесал».
 
* Удалил класс *TMaskUtil*, который состоял из единственного метода (*GetDataMaskBit*), вызывавшегося только в одном месте.
Метод перенесён туда, где он нужен. Аналогично удалил функцию *GetModeBits*, потому что она состояла из одной простейшей
строчки и вызывалась только в одном месте, куда я эту строчку и перенёс.

* Класс *TECB* заменён на запись, так как он состоял всего из двух полей и методов для их чтения. Бесполезная вещь, как
мне кажется.

* Добавлено много поясняющих комментариев в тех местах, где что-то было особенно непонятно.

* Возможно что-то ещё, о чём я уже не могу вспомнить.

## 8. Модуль *QRGraphics.pas* ##

В DelphiZXingQRCode никаких средств преобразования QR-кода в графическое представление не было. Только
демонстрационный пример показывал, как сгенерировать простейшую битовую матрицу. Мне этого показалось мало.

Модуль *QRGraphics.pas* содержит несколько функций: для отрисовки QR-кода на заданной канве (*TCanvas*), для генерации
битовой матрицы и для создания метафайла. 

Небольшой бонус: в демонстрационном примере имеется кусочек кода, который сохраняет картинку в формате JPEG (обработчик
кнопки *btnSaveToFile*).

## 9. Демонстрационная программа *TestApp* ##

Эта программа настолько переделана, что можно говорить скорее о создании с нуля. Фактически её теперь можно даже
использовать как отдельное приложение для генерации различных QR-кодов. В частности, она умеет сохранять файлы
в форматах BMP, EMF и JPEG.
